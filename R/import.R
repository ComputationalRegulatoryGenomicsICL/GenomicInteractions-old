# import methods

#' Function to process names relating to interactions stored in bed12 formats.
#'
#' In bed(n) formats interaction data cannot be stored directly due to the inability of the format to handle
#' trans-interactions. It is only capable of storing cis-interactions through the use of blockStarts and blockEnds.
#' As such the information is typically stored as a string of the format chr1:start1..end1-chr2:start2..end2,N
#' (e.g. \"chr1:3268539..3269061-chr10:103124111..103124631,4\".). This function takes a vector of these strings
#' and converts them to a data.frame.
#'
#' @param x a vector of names stored in the bed file
#'
#' @return a data.frame containing all of the processed information
#'
#' @importFrom stringr str_split
.processChiapetName = function(x){
  tmp.str = str_split(x, ",")
  counts = as.integer(unlist(lapply(tmp.str, function(y){ return(y[2] ) } )))
  tmp.str.2 = sapply(tmp.str, function(y){
    str_split(y[1], "-")
  })
  paired.end.1 = t(sapply(tmp.str.2, function(y){
    tmp = str_split(y[[1]], ":")
    chr = tmp[[1]][1]
    tmp = str_split(tmp[[1]][2], "\\.\\.")
    start = as.integer(tmp[[1]][1]) + 1
    end = as.integer(tmp[[1]][2])
    return(c(chr, start, end))
  }))
  paired.end.2 = t(sapply(tmp.str.2, function(y){
    tmp = str_split(y[[2]], ":")
    chr = tmp[[1]][1]
    tmp = str_split(tmp[[1]][2], "\\.\\.")
    start = as.integer(tmp[[1]][1]) + 1
    end = as.integer(tmp[[1]][2])
    return(c(chr, start, end))
  }))
  dat = cbind(paired.end.1, paired.end.2, counts)
  colnames(dat) = c("chrom.left.", "start.left.", "end.left.", "chrom.right.", "start.right.", "end.right.", "counts")
  return(dat)
}


#' Function to read in processed Hi-C interaction data generated by HOMER
#'
#' This function reads in the interaction data outputted by HOMER (http://homer.salk.edu/homer/interactions/).
#'
#' @param fn location of data exported by HOMER
#' @return a data frame containing the relevant information
#'
.importHomer = function(fn){
  HOMER_int.df <- read.table(fn, header=TRUE, stringsAsFactors=FALSE, sep="\t")
  #convert to closed format
  #already 1-based
  HOMER_int.df$end.1. <- HOMER_int.df$end.1. - 1
  HOMER_int.df$end.2. <- HOMER_int.df$end.2. - 1
  return(HOMER_int.df)
}


#' Function to read in processed Hi-C interaction data generated by hiclib
#'
#' This function reads in the interaction data processed by [hiclib](https://bitbucket.org/mirnylab/hiclib). The data is extracted from hiclib and
#' exported from its internal HDF5 format to text using h5dictToTxt.py. This function reads in the relevant files present in the
#' directory and generates a data.table containing all of the information. It assumes that there are files with the following
#' names in the directory: fragids1, chrms1, mids1, fraglens1, fragids2, chrms2, mids2, fraglens2, distances.
#'
#' @param dir directory containing the output files generated by hiclib, extracted using h5dictToTxt.py
#' @param genome BSGenome to use for constructing the GenomicInteractions object.
#' @return data.table containing information on the individual interactions
#'
#' @import data.table
#'
.importHicLib = function(dir, genome){

  .process.chr = function(chrs, genome){

    chrs = as.numeric(chrs)+1
    chrs = ifelse( names(seqlengths(genome)[chrs]) %in% c("chrY"), "Y", chrs)
    chrs = ifelse( names(seqlengths(genome)[chrs]) %in% c("chrX"), "X", chrs)
    return( paste0("chr", chrs ))
  }

  frags=data.table(fragid1=fread(paste0(dir, "fragids1"))$V1, chrm1=.process.chr(fread(paste0(dir, "chrms1"))$V1, genome),
                   mid1=fread(paste0(dir, "mids1"))$V1, fraglength1 = fread(paste0(dir, "fraglens1"))$V1,
                   fragid2=fread(paste0(dir, "fragids2"))$V1, chrm2=.process.chr(fread(paste0(dir, "chrms2"))$V1, genome),
                   mid2=fread(paste0(dir, "mids2"))$V1, fraglength2 = fread(paste0(dir, "fraglens2"))$V1,
                   distances=fread(paste0(dir, "distances"))$V1, stringsAsFactors=FALSE)
  frags_agg <- frags[, .N, by=names(frags)]

  return(frags_agg)
}


#' Function to read in interaction-data stored in a BAM file
#'
#' Reads in interactions stored in a BAM file. Assumes that each interaction is represented by pair of PETs
#' with the same qname. The function reads in and determines which anchor is which by examining the
#' isFirstMateRead and isSecondMateRead fields in the BAM file.
#'
#' @param fn name of BAM file containing interaction information
#' @param genome BSGenome to use for constructing the GenomicInteractions object.
#' @return list of GRanges - storing the anchor information for each interaction
#'
#' @importFrom Rsamtools scanBamFlag ScanBamParam scanBam
#' @import GenomicRanges
#'
.readBam = function(fn, genome){
  bf = scanBamFlag(isPaired = TRUE, isDuplicate=FALSE)
  param = ScanBamParam(flag=bf, what=c("rname", "qname", "strand", "pos", "seq", "cigar", "flag") )
  b = scanBam(fn, param=param)

  y = GRanges(b[[1]]$rname, IRanges(b[[1]]$pos, width=width(b[[1]]$seq)), strand = b[[1]]$strand,
                                                                              qname = b[[1]]$qname,
                                                                              bamFlagAsBitMatrix(b[[1]][["flag"]], bitnames="isFirstMateRead"),
                                                                              bamFlagAsBitMatrix(b[[1]][["flag"]], bitnames="isSecondMateRead")    ,
                                                                              seqlengths=seqlengths(genome)
              )

  y1 = y[ y$isFirstMateRead == 1 ]
  y2 = y[ y$isSecondMateRead == 1]

  y1 = y1[ y1$qname %in% unique(y1$qname)]
  y2 = y2[ y2$qname %in% unique(y2$qname)]

  y1 = y1[ order(y1$qname) ]
  y2 = y2[ order(y2$qname) ]
  y1$isFirstMateRead = NULL
  y1$isSecondMateRead = NULL
  y2$isSecondMateRead = NULL
  y2$isFirstMateRead = NULL
  return(list(y1, y2))

}

#' Function to read in interaction-data stored in a pair of BAM files
#'
#' Reads in interactions stored in a a pair of BAM files, e.g. from independent 
#' alignment of paired-end reads. Assumes that each interaction is represented 
#' by pair of PETs with the same qname (this may not always be true. Depending 
#' on data origin read qnames may end in '/1' or '/2' to denote first or second 
#' read in the pair). The function reads in files, removes unpaired reads, and 
#' pairs reads based on macthing qnames.
#'
#' @param fn Character vector of two BAM files with aligned reads. 
#' @param genome BSGenome to use for constructing the GenomicInteractions object.
#' @return list of two GRanges, storing the anchor information for each interaction
#'
#' @importFrom Rsamtools scanBamFlag ScanBamParam scanBam
#' @import GenomicRanges
#'
.readTwoBams = function(fn, genome){
    
    if (length(fn)!=2){
        stop("Must supply two bam files for this import method")
    }
    
    bf = scanBamFlag(isUnmappedQuery=FALSE)
    param = ScanBamParam(flag=bf, what=c("rname", "qname", "strand", "pos", "seq"))
    
    message("Reading first bam file...")
    b1 = scanBam(fn[1], param=param)
    g1 = GRanges(as.character(b1[[1]]$rname), IRanges(b1[[1]]$pos, width=width(b1[[1]]$seq)), strand = as.character(b1[[1]]$strand),
                 qname = b1[[1]]$qname)
    seqinfo(g1) <- seqinfo(genome)
    rm(b1)
    
    message("Reading second bam file...")
    b2 = scanBam(fn[2], param=param)
    g2 = GRanges(as.character(b2[[1]]$rname), IRanges(b2[[1]]$pos, width=width(b2[[1]]$seq)), strand = as.character(b2[[1]]$strand),
                 qname = b2[[1]]$qname)
    seqinfo(g2) <- seqinfo(genome)
    rm(b2)
    
    message("Removing unpaired reads...")
    g1 <- g1[g1$qname %in% g2$qname]
    g2 <- g2[g2$qname %in% g1$qname]
    
    message("Pairing reads...")
    g1 <- g1[order(g1$qname)]
    g2 <- g2[order(g2$qname)]
    
    return(list(g1, g2))
}

#' Summarise Interactions between defined anchors
#'
#' Calculate the number of of paired-end reads mapping between a defined set of anchors.
#' This function will ignore counts present in the input data.
#'
#' @return A GenomicInteractions object with annotated counts between anchors
#' @docType methods
#' @rdname countsBetweenAnchors-methods
#' @export
setGeneric("countsBetweenAnchors",function(x, y){standardGeneric ("countsBetweenAnchors")})

#' @param x A GenomicInteractions object
#' @param y A GenomicRanges object
#' @import GenomicRanges
#' @rdname countsBetweenAnchors-methods
#' @docType methods
#' @export
setMethod("countsBetweenAnchors", list("GenomicInteractions", "GRanges"), function(x, y) {
    #check anchors are unique
    if (any(countOverlaps(y, y) > 1)) stop("anchors are not unique")
    one = overlapsAny(anchorOne(x), y)
    two = overlapsAny(anchorTwo(x), y)
    x.valid = x[one & two]
    overlaps = findOverlaps(sort(x.valid), y, select="first") # select produces matrix not Hits
    interactions = paste(overlaps[[1]], overlaps[[2]], sep=":")
    tabulated = table(interactions)

    pairs_list = strsplit(names(tabulated), ":")
    pairs_one = as.integer(sapply(pairs_list, function(x) x[1]))
    pairs_two = as.integer(sapply(pairs_list, function(x) x[2]))

    anchor_one = y[pairs_one]
    anchor_two = y[pairs_two]
    counts = as.integer(tabulated)

    final_counts = new("GenomicInteractions",
                       experiment_name = name(x),
                       description = description(x),
                       genome_name = genomeName(x),
                       anchor_one=anchor_one,
                       anchor_two=anchor_two,
                       counts=counts)

    return(sort(final_counts))
})

